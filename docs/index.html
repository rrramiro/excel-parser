<!DOCTYPE html>
<html>
  <head>
    <title>Excel Parser</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; font-size: 120%; }
    </style>
  </head>
  <body>
    <textarea id="source">




class: center, middle

# Functional Programming use case: Excel Parser
`@JulienTruffaut`

???
- notes here
- see https://remarkjs.com/#1

---
# Use case

.center[![workbook](workbook-intro.png)]

---
# Use case

.center[![workbook](workbook-with-name.png)]

---
# Excel API: Workbook

```scala

libraryDependencies += "org.apache.poi" % "poi-ooxml" % "5.1.0"

```

```scala mdoc:silent
import org.apache.poi.ss.usermodel.{Workbook, WorkbookFactory}

def load(fileName: String): Workbook =
    WorkbookFactory.create(getClass.getClassLoader.getResourceAsStream(fileName))

val workbook = load("example.xlsx")
```

```


```

All codes and slides are available on github at `julien-truffaut/excel-parser`

---
# Excel API: Name

```scala mdoc
val oilProd = workbook.getName("OilProd")

val oilProdFormula = oilProd.getRefersToFormula
```

.center[![workbook](workbook.png)]

---
# Excel API: AreaReference
```scala mdoc:invisible:reset
import parser._
```
```scala mdoc:silent
import org.apache.poi.ss.util.AreaReference

val oilProdFormula = workbook.getName("OilProd").getRefersToFormula

val area = new AreaReference(oilProdFormula, workbook.getSpreadsheetVersion)
```

```scala mdoc
val cellRefs = area.getAllReferencedCells

```
---
# Excel API: Cell

```scala mdoc:silent
val cellRef = cellRefs.head

val cell = workbook.
  getSheet(cellRef.getSheetName).
  getRow(cellRef.getRow).
  getCell(cellRef.getCol)
```

--

```scala mdoc
cell.getNumericCellValue
```

--

```scala mdoc:crash
cell.getStringCellValue
```

---
# Cell error handling

```scala mdoc:silent
case class ParserError(ref: String, expectedFormat: String, message: String)
type EitherParserError[T] = Either[ParserError, T]
```

--

```scala mdoc:silent
import cats.syntax.either._
import org.apache.poi.ss.usermodel.Cell

case class SafeCell(cell: Cell){
  val reference = s"${cell.getSheet.getSheetName}!${cell.getAddress}"

  def asDouble: EitherParserError[Double] =
    Either.catchNonFatal(cell.getNumericCellValue).leftMap(e =>
      ParserError(reference, "Numeric", e.getMessage)
    )

  def asString: EitherParserError[String] =
    Either.catchNonFatal(cell.getStringCellValue).leftMap(e =>
      ParserError(reference, "String", e.getMessage)
    )
}
```

---
# Cell error handling

```scala mdoc:silent
val safeCell = SafeCell(cell)
```

```scala mdoc
safeCell.asDouble
safeCell.asString
```

---
# Parsing API

```scala mdoc:silent

def numericRange(workbook: Workbook, name: String): EitherParserError[List[Double]] = ???

def numeric(workbook: Workbook, name: String): EitherParserError[Double] = ???

def stringRange(workbook: Workbook, name: String): EitherParserError[List[String]] = ???

def string(workbook: Workbook, name: String): EitherParserError[String] = ???

```

```scala mdoc:crash:silent
numericRange(workbook, "OilProd")
```

---
# Parsing Doubles

```scala mdoc:invisible:reset
import parser._
```

```scala mdoc:silent
def numericRange(workbook: Workbook, name: String): EitherParserError[List[Double]] = {
  val formula = workbook.getName(name).getRefersToFormula
  val area    = new AreaReference(formula, workbook.getSpreadsheetVersion)
  val cells   = area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  )

  val safeCells: List[SafeCell] = cells.map(SafeCell)
  val doubles: List[EitherParserError[Double]] = safeCells.map(_.asDouble)
  ???
}
```

---
# Parsing Doubles

```scala mdoc:invisible:reset
import parser._
```

```scala mdoc:silent
import cats.syntax.traverse._
import cats.instances.either._
import cats.instances.list._

def numericRange(workbook: Workbook, name: String): EitherParserError[List[Double]] = {
  val formula = workbook.getName(name).getRefersToFormula
  val area    = new AreaReference(formula, workbook.getSpreadsheetVersion)
  val cells   = area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  )

  val safeCells: List[SafeCell] = cells.map(SafeCell)
  val doubles: List[EitherParserError[Double]] = safeCells.map(_.asDouble)
  doubles.sequence
}
```

---
# Parsing Doubles

```scala mdoc:invisible:reset
import cats.syntax.traverse._
import cats.instances.either._
import cats.instances.list._
import parser._
```

```scala mdoc:silent
def numericRange(workbook: Workbook, name: String): EitherParserError[List[Double]] = {
  val area = new AreaReference(workbook.getName(name).getRefersToFormula, workbook.getSpreadsheetVersion)
  area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  ).map(SafeCell).traverse(_.asDouble)
}
```

--

```scala mdoc
numericRange(workbook, "OilProd")
numericRange(workbook, "PrimaryProduct")
```

---
# Parsing Doubles

```scala mdoc:invisible:reset
import parser._
import cats.syntax.traverse._
import cats.instances.either._
import cats.instances.list._
```

```scala mdoc:silent
def numericRange(workbook: Workbook,
                 name: String): EitherParserError[List[Double]] = {
  val area = new AreaReference(workbook.getName(name).getRefersToFormula, workbook.getSpreadsheetVersion)
  area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  ).map(SafeCell).traverse(_.asDouble)
}
```

```scala mdoc:crash
numericRange(workbook, "foo")
```

---
# Parsing Doubles

```scala mdoc:invisible:reset
import parser._
import cats.syntax.either._
```

```scala mdoc:silent
sealed trait ParserError extends Product with Serializable
case class InvalidFormat(ref: String, expectedFormat: String, message: String) extends ParserError
case class MissingName(name: String) extends ParserError
case class MissingCell(ref: String) extends ParserError
type EitherParserError[T] = Either[ParserError, T]
```

```scala mdoc:silent
def getArea(workbook: Workbook, name: String): EitherParserError[AreaReference] =
  Either.catchNonFatal(
    new AreaReference(workbook.getName(name).getRefersToFormula, workbook.getSpreadsheetVersion)
  ).leftMap(_ => MissingName(name))

def getSafeCell(workbook: Workbook, cellRef: CellReference): EitherParserError[SafeCell] =
  Either.catchNonFatal(SafeCell(
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  )).leftMap(_ => MissingCell(cellRef.toString))
```

---
# Parsing doubles

```scala mdoc:invisible:reset
import parser._
import Parser._
import cats.syntax.traverse._
import cats.instances.either._
import cats.instances.list._
```

```scala mdoc:silent
def numericRange(workbook: Workbook, name: String): EitherParserError[List[Double]] =
  for {
    area    <- getArea(workbook, name)
    cells   <- area.getAllReferencedCells.toList.traverse(getSafeCell(workbook, _))
    doubles <- cells.traverse(_.asDouble)
  } yield doubles
```

```scala mdoc
numericRange(workbook, "OilProd")
numericRange(workbook, "PrimaryProduct")
numericRange(workbook, "foo")
```

---
# Parsing Semigroupal

```scala mdoc:silent
case class Production(oil: List[Double], gas: List[Double])

def production(workbook: Workbook,
               oilName: String,
               gasName: String
               ): EitherParserError[Production] = ???
```

---
# Parsing Semigroupal

```scala mdoc:invisible:reset
import parser._
import Parser0._
```

```scala mdoc:silent
case class Production(oil: List[Double], gas: List[Double])

def production(workbook: Workbook,
               oilName: String,
               gasName: String
               ): EitherParserError[Production] =
  for {
    oil <- numericRange(workbook, oilName)
    gas <- numericRange(workbook, gasName)
  } yield Production(oil, gas)
```

---
# Parsing Semigroupal

```scala mdoc:silent
trait Parser[A]

def product[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] = ???
```

---
# Parsing Semigroupal
```scala mdoc:invisible:reset
import parser._
```

```scala mdoc:silent
trait Parser[A]{
  def parse(workbook: Workbook, name: String): EitherParserError[A]
}
```

--

```scala mdoc:silent
val numericRange = new Parser[List[Double]]{
  def parse(workbook: Workbook, name: String): EitherParserError[List[Double]] = ???
}
```

```scala mdoc:silent
def numericRange(workbook: Workbook, name: String): EitherParserError[List[Double]] = ???
```

---
# Parsing Semigroupal
```scala mdoc:invisible:reset
import parser._
```
```scala mdoc:silent
trait Parser[A]{
  def parse(workbook: Workbook, name: String): EitherParserError[A]
}


def product[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] =
  new Parser[(A, B)]{
    def parse(workbook: Workbook, name: String): EitherParserError[(A, B)] =
      for {
        a <- pa.parse(workbook, ???)
        b <- pb.parse(workbook, ???)
      } yield (a, b)
  }
```

---
# Parser
```scala mdoc:invisible:reset
import parser._
import Parser._
import cats.syntax.traverse._
import cats.instances.either._
import cats.instances.list._

```
```scala mdoc:silent
trait Parser[A]{
  def parse(workbook: Workbook): EitherParserError[A]
}
```

--

```scala mdoc:silent
def numericRange(name: String): Parser[List[Double]] =
  new Parser[List[Double]]{
    def parse(workbook: Workbook): EitherParserError[List[Double]] =
      for {
        area    <- getArea(workbook, name)
        cells   <- area.getAllReferencedCells.toList.traverse(getSafeCell(workbook, _))
        doubles <- cells.traverse(_.asDouble)
      } yield doubles
  }
```

---
# Parsing Semigroupal

```scala mdoc:silent
def product[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] =
  new Parser[(A, B)]{
    def parse(workbook: Workbook): EitherParserError[(A, B)] =
      for {
        a <- pa.parse(workbook)
        b <- pb.parse(workbook)
      } yield (a, b)
  }
```

--

```scala mdoc:silent
val oil = numericRange("OilProd")
val gas = numericRange("GasProd")
val foo = numericRange("Foo")
```

```scala mdoc
product(oil, gas).parse(workbook)
product(oil, foo).parse(workbook)
```

---
# Parsing Production

```scala mdoc
product(oil, gas).parse(workbook)
```

```scala mdoc:silent
case class Production(oil: List[Double], gas: List[Double])

def production: Parser[Production] = ???
```

---
# Map
```scala mdoc:invisible:reset
import parser._
import Parser._

val oil = numericRange("OilProd")
val gas = numericRange("GasProd")
```
```scala mdoc:silent
def map[A, B](pa: Parser[A])(f: A => B): Parser[B] =
  new Parser[B]{
    def parse(workbook: Workbook): EitherParserError[B] =
      pa.parse(workbook).map(f)
  }
```

--

```scala mdoc:silent
val production = map(product(oil, gas)){case (oil, gas) => Production(oil,gas)}
```

```scala mdoc
production.parse(workbook)
```

---
# Parser is a Semigroupal Functor

```scala mdoc:silent
trait Functor[F[_]]{
  def map[A,B](fa: F[A])(f: A => B): F[B]
}

trait Semigroupal[F[_]]{
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
```

---
# Parser is a Semigroupal Functor

```scala mdoc:crash
implicit val semigroupalFunctor: Functor[Parser] with Semigroupal[Parser] = ???
```

```scala mdoc:invisible:reset
import parser._
import Parser._
import cats.instances.list._
```

```scala mdoc:silent
import cats.syntax.all._

val oil = numericRange("OilProd")
val gas = numericRange("GasProd")
val foo = numericRange("Foo")

val production = (oil, gas).mapN(Production)
```

--

```scala mdoc:silent
(oil, gas, foo).tupled
```

---
# Coproduct

```scala mdoc:silent
sealed trait Fee extends Product with Serializable
case class TechnicalFee(technical: Double) extends Fee
case class ExplorationFee(exploration: Double, postExploration: Double) extends Fee
```

--

```scala mdoc:invisible
def numeric(name: String): Parser[Double] =
  new Parser[Double]{
    def parse(workbook: Workbook) =
      for {
        area    <- getArea(workbook, name)
        cells   <- area.getAllReferencedCells.toList.traverse(getSafeCell(workbook, _))
        double  <- cells.head.asDouble
      } yield double
  }
```

```scala mdoc:silent
val technicalFee: Parser[TechnicalFee] = numeric("TechnicalFee").map(TechnicalFee)

val explorationFee: Parser[ExplorationFee] =
  (numeric("ExplorationFee"), numeric("PostExplorationFee")).mapN(ExplorationFee)
```

--

```scala mdoc
technicalFee.parse(workbook)
explorationFee.parse(workbook)
```

```scala mdoc:crash
val fee: Parser[Fee] = ???
```

---
# Combine

```scala mdoc:invisible:reset
import parser._
import Combine0._
```

```scala mdoc:silent
def combine[A](p1: Parser[A], p2: Parser[A]): Parser[A] = new Parser[A]{
  def parse(workbook: Workbook): Either[ParserError, A] =
    p1.parse(workbook) orElse p2.parse(workbook)
}
```

--

```scala mdoc:fail
val fee = combine(technicalFee, explorationFee)
```

---
# Combine

```scala mdoc:invisible:reset
import parser._
import Combine0._
import cats.syntax.all._
```
```scala mdoc:silent
val fee = combine(
  technicalFee.map(f => f: Fee),
  explorationFee.map(f => f: Fee)
)
```

--
```scala mdoc:invisible:reset
import parser._
import Combine0._
import cats.syntax.all._
```
```scala mdoc:silent
val fee = combine(
  technicalFee.widen[Fee],
  explorationFee.widen[Fee]
)
```

```scala mdoc
fee.parse(workbook)
```

---
# Parser is a SemigroupK
```scala mdoc:invisible:reset
import parser._
```
```scala mdoc:silent
trait Semigroup[A]{
  def combine(x: A, y: A): A
}

trait SemigroupK[F[_]]{
  def combineK[A](x: F[A], y: F[A]): F[A]
}
```

--

```scala mdoc:silent:crash
implicit val parserSemigroupK: SemigroupK[Parser] = ??? //TODO
```
```scala mdoc:invisible:reset
import parser._
import Combine0._
import cats.syntax.all._
```
```scala mdoc:silent
val fee = technicalFee.widen[Fee] <+> explorationFee.widen[Fee]
```

```scala mdoc
fee.parse(workbook)
```

---
# How to find abstractions

```scala mdoc:silent
def numericRange(workbook: Workbook, name: String): List[Double] = ???
```

--
```scala mdoc:invisible:reset
import parser._
```
```scala mdoc:silent
def numericRange(workbook: Workbook, name: String): Either[ParserError, List[Double]] = ???
```

--

```scala mdoc:silent
trait Parser[A]{
  def parse(workbook: Workbook): Either[ParserError, A]
}

def product[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] = ???

def combine[A](pa: Parser[A], pb: Parser[A]): Parser[A] = ???
```

--
```scala mdoc:invisible:reset
import parser.Parser
import cats._
```
```scala mdoc:silent
implicit def instances: Monad[Parser] with SemigroupK[Parser]  = ???
```

---
# Is it worth it?
```scala mdoc:invisible:reset
import parser._
import Parser._
import cats.syntax.all._
```
```scala mdoc:silent
val technicalFee = numeric("TechnicalFee").map(TechnicalFee)

val explorationFee = (numeric("ExplorationFee"), numeric("PostExplorationFee"))
    .mapN(ExplorationFee)

val fee = technicalFee.widen[Fee] <+> explorationFee.widen[Fee]
```

---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/excel-parser` on GitHub

## Questions?

---
# Bonus: Sequential composition

```scala mdoc:reset:invisible
import cats.syntax.all._
import parser.Parser._
```

```scala mdoc:silent
sealed trait Cost extends Product with Serializable

case class Hardcoded(value: List[Double]) extends Cost
case class Parametrized(value: Double) extends Cost

val cost = boolean("Cost").flatMap{
  case true  => numericRange("HardcodedCost").map(Hardcoded).widen[Cost]
  case false => numeric("ParametrizedCost").map(Parametrized).widen[Cost]
}
```
 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        slideNumberFormat: '',
        ratio: "16:9"
      });
    </script>
  </body>
</html>
